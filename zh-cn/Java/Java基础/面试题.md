---
title: Java基础面试题
subtitle: Java基础
image: 
alt: 
date: 2021-01-20 19:18:45

caption:
  title: Java基础面试题
  subtitle: Java基础
  thumbnail: https://wimg.ruan8.com/uploadimg/image/20190402/20190402163328_31815.jpg
---
# 面试

## 一、Java基础

### 1、==和equals的区别
>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型 == 比较的值，引用数据类型 == 比较的是内存地址)。
>
>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
>
>1. 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
>2. 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。  

<br>

### 2、hashCode()和equals()方法的关系
>equals：比较的是两个对象的内存地址值
>hashCode：比较的是两个对象在hash表中的位置
>
>hashCode的由来：对象的内存地址通过hash函数算法得到hashcode
>1. equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
>2. hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。
>
>HashCode的存在主要是为了查找的快捷性
>　　每当需要对比两个对象是否相等的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就不必再用equal()去对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！

<br>

### 3、final关键字的功能概述
>final关键字可以用来修饰引用、方法和类。
>
>1. 用来修饰一个引用
>    * 如果引用为基本数据类型，则该引用为常量，该值无法修改；
>    * 如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。
>    * 如果引用时类的成员变量，则必须当场赋值，否则编译会报错。
>2. 用来修饰一个方法  
>    当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。
>3. 用来修饰类  
   当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。

<br>

### 4、java 中操作字符串都有哪些类？它们之间有什么区别？
>String、StringBuffer、StringBuilder
>
>* String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。
>* StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。
>* StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。  
>详情请看博客
[弄清Java中的String，StringBuilder，StringBuffer的区别](https://blog.csdn.net/u013523775/article/details/107964562)  

<br>

### 5、HashMap和Hashtable有什么区别？
>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
>
>1. 继承的父类不同  
   Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。
>2. 线程安全性不同  
   Hashtable是同步的(线程安全)，而HashMap不是。因此，HashMap更适合于单线程环境(速度快)，而Hashtable适合于多线程环境。
>3. 是否提供contains方法
      * HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。
      * Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同。
>4. key和value是否允许null值  
   HashMap允许键和值是null，而Hashtable不允许键或者值是null。
>5. hash值不同  
    哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。

<br>

### 6、HashMap详解
>详情请看下一篇博客

<br>

### 7、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？
>下面列出了Array和ArrayList的不同点：
>1. Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。*但是需要注意的是：Array数组在存放的时候一定是同种类型的元素。ArrayList就不一定了，因为ArrayList可以存储Object。*
>2. Array大小是固定的，ArrayList的大小是动态变化的。如果空间不够，它会创建一个空间比原空间大一倍的新数组，然后将所有元素复制到新数组中，接着抛弃旧数组。而且，每次添加新的元素的时候都会检查内部数组的空间是否足够。（比较麻烦的地方）。
>3. ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
>4. 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
>5. 适用场景：
如果想要保存一些在整个程序运行期间都会存在而且不变的数据，我们可以将它们放进一个全局数组里，但是如果我们单纯只是想要以数组的形式保存数据，而不对数据进行增加等操作，只是方便我们进行查找的话，那么，我们就选择ArrayList。而且还有一个地方是必须知道的，就是如果我们需要对元素进行频繁的移动或删除，或者是处理的是超大量的数据，那么，使用ArrayList就真的不是一个好的选择，因为它的效率很低，使用数组进行这样的动作就很麻烦，那么，我们可以考虑选择LinkedList。
>
>详情请看博客


### 8、枚举

>[Java面试必知必会.Java基础.04.枚举](https://www.bilibili.com/video/BV14e411x7Sh)  
枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。
