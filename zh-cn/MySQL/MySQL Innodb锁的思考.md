---
title: MySQL——Innodb中 表锁和行锁的思考
subtitle: MySQL——Innodb中 表锁和行锁的思考
image: https://img-blog.csdnimg.cn/20210124225711901.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM1MjM3NzU=
alt: MySQL
date: 2021-01-23 17:44:36

caption:
  title: MySQL——Innodb中 表锁和行锁的思考
  subtitle: MySQL——Innodb中 表锁和行锁的思考
  thumbnail: https://wimg.ruan8.com/uploadimg/image/20190402/20190402163328_31815.jpg
---

# MySQL——Innodb中的锁及四种隔离级别

<br>

## InnoDB存储引擎实现了两种标准的锁

>共享锁(S-Lock)：也就是读锁

MySQL读锁，是读取操作创建的锁，是不阻塞的，其他的用户可以并发数据，但任何用户都不可以修改数据，直到释放。当上锁时候可以读可以加锁，但不可以更新。


>排它锁(X-Lock)：也就是写锁

MySQL写锁，如果事务A对行加入写锁，写锁是阻塞的，其他事务将不能再对该行加任何锁，事务A可以读可以改，其他事务将被阻塞

<br>


## Innodb中的行锁与表锁

### 行锁

行锁可以最大程度的支持并发策略，同时也带来了最大的锁开销

InnoDB行锁是通过给索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！

行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的,会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。

在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。

### 表锁
表锁是MySQL中最基本的锁策略，是开销最小的策略。
表锁会锁住整张表，会阻塞其他用户对该表的所有读写操作


<br>

### 行级锁与死锁
MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。

在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。 在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。

当两个事务同时执行，一个锁住了逐渐索引在等待其他相关索引，一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。

发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

有多种方法可以避免死锁，这里只介绍常见的三种，具体如下

1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

<br>

## Innodb的四种事务隔离级别
>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted(未授权读取、读未提交)、Read committed（授权读取、读提交）、Repeatable read（可重复读取）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻象读这几类问题。

#### 1. Read uncommitted(未授权读取、读未提交)： 
如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现。这样就避免了更新丢失，却可能出现脏读。也就是说事务B读取到了事务A未提交的数据。
>会出现脏读的问题
#### 2. Read committed（授权读取、读提交）： 
读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。该隔离级别避免了脏读，但是却可能出现不可重复读。事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
>解决了脏读的问题，但是不可以重复读，同一个事务对数据的多次读取的结果不一致。
#### 3.Repeatable read（可重复读取）： 
可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，即使第二个事务对数据进行修改，第一个事务两次读到的的数据是一样的。这样就发生了在一个事务内两次读到的数据是一样的，因此称为是可重复读。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻读。（读取数据的事务）这可以通过“共享读锁”和“排他写锁”实现。
>解决了脏读和不可重复读的问题，但会出现幻读的问题。
>可重复度是MySQL默认的事务隔离级别，Innodb通过MVCC（多版本并发控制）解决了幻读的问题
#### 4.Serializable（序列化）： 
提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。 
>事务只能一件一件的进行，不能并发进行。